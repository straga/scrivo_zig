/*
 * ZigBee Cluster Library Attribute Types
 * Based on esp_zb_zcl_attr_type_t enum type
 * Generated by generate_separate_modules.py on 2025-05-25 11:05:08
 */

#include "py/runtime.h"
#include "py/obj.h"
#include "py/objstr.h"
#include <string.h>
#include "ZCL_ATTR_TYPE.h"

// Module-level function implementations - NO INTERMEDIATE CLASS
// get_type method implementation
mp_obj_t mod_zigbee_attrtype_get_type(mp_obj_t value_in) {
    mp_int_t value = mp_obj_get_int(value_in);
    
    // Return type information based on value
    switch (value) {
        case 0x00:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_NULL", strlen("ESP_ZB_ZCL_ATTR_TYPE_NULL"));
        case 0x08:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_8BIT", strlen("ESP_ZB_ZCL_ATTR_TYPE_8BIT"));
        case 0x09:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_16BIT", strlen("ESP_ZB_ZCL_ATTR_TYPE_16BIT"));
        case 0x0a:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_24BIT", strlen("ESP_ZB_ZCL_ATTR_TYPE_24BIT"));
        case 0x0b:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_32BIT", strlen("ESP_ZB_ZCL_ATTR_TYPE_32BIT"));
        case 0x0c:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_40BIT", strlen("ESP_ZB_ZCL_ATTR_TYPE_40BIT"));
        case 0x0d:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_48BIT", strlen("ESP_ZB_ZCL_ATTR_TYPE_48BIT"));
        case 0x0e:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_56BIT", strlen("ESP_ZB_ZCL_ATTR_TYPE_56BIT"));
        case 0x0f:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_64BIT", strlen("ESP_ZB_ZCL_ATTR_TYPE_64BIT"));
        case 0x10:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_BOOL", strlen("ESP_ZB_ZCL_ATTR_TYPE_BOOL"));
        case 0x18:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_8BITMAP", strlen("ESP_ZB_ZCL_ATTR_TYPE_8BITMAP"));
        case 0x19:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_16BITMAP", strlen("ESP_ZB_ZCL_ATTR_TYPE_16BITMAP"));
        case 0x1a:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_24BITMAP", strlen("ESP_ZB_ZCL_ATTR_TYPE_24BITMAP"));
        case 0x1b:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_32BITMAP", strlen("ESP_ZB_ZCL_ATTR_TYPE_32BITMAP"));
        case 0x1c:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_40BITMAP", strlen("ESP_ZB_ZCL_ATTR_TYPE_40BITMAP"));
        case 0x1d:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_48BITMAP", strlen("ESP_ZB_ZCL_ATTR_TYPE_48BITMAP"));
        case 0x1e:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_56BITMAP", strlen("ESP_ZB_ZCL_ATTR_TYPE_56BITMAP"));
        case 0x1f:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_64BITMAP", strlen("ESP_ZB_ZCL_ATTR_TYPE_64BITMAP"));
        case 0x20:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_U8", strlen("ESP_ZB_ZCL_ATTR_TYPE_U8"));
        case 0x21:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_U16", strlen("ESP_ZB_ZCL_ATTR_TYPE_U16"));
        case 0x22:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_U24", strlen("ESP_ZB_ZCL_ATTR_TYPE_U24"));
        case 0x23:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_U32", strlen("ESP_ZB_ZCL_ATTR_TYPE_U32"));
        case 0x24:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_U40", strlen("ESP_ZB_ZCL_ATTR_TYPE_U40"));
        case 0x25:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_U48", strlen("ESP_ZB_ZCL_ATTR_TYPE_U48"));
        case 0x26:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_U56", strlen("ESP_ZB_ZCL_ATTR_TYPE_U56"));
        case 0x27:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_U64", strlen("ESP_ZB_ZCL_ATTR_TYPE_U64"));
        case 0x28:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_S8", strlen("ESP_ZB_ZCL_ATTR_TYPE_S8"));
        case 0x29:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_S16", strlen("ESP_ZB_ZCL_ATTR_TYPE_S16"));
        case 0x2a:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_S24", strlen("ESP_ZB_ZCL_ATTR_TYPE_S24"));
        case 0x2b:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_S32", strlen("ESP_ZB_ZCL_ATTR_TYPE_S32"));
        case 0x2c:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_S40", strlen("ESP_ZB_ZCL_ATTR_TYPE_S40"));
        case 0x2d:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_S48", strlen("ESP_ZB_ZCL_ATTR_TYPE_S48"));
        case 0x2e:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_S56", strlen("ESP_ZB_ZCL_ATTR_TYPE_S56"));
        case 0x2f:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_S64", strlen("ESP_ZB_ZCL_ATTR_TYPE_S64"));
        case 0x30:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_8BIT_ENUM", strlen("ESP_ZB_ZCL_ATTR_TYPE_8BIT_ENUM"));
        case 0x31:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_16BIT_ENUM", strlen("ESP_ZB_ZCL_ATTR_TYPE_16BIT_ENUM"));
        case 0x38:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_SEMI", strlen("ESP_ZB_ZCL_ATTR_TYPE_SEMI"));
        case 0x39:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_SINGLE", strlen("ESP_ZB_ZCL_ATTR_TYPE_SINGLE"));
        case 0x3a:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_DOUBLE", strlen("ESP_ZB_ZCL_ATTR_TYPE_DOUBLE"));
        case 0x41:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_OCTET_STRING", strlen("ESP_ZB_ZCL_ATTR_TYPE_OCTET_STRING"));
        case 0x42:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING", strlen("ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING"));
        case 0x43:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_LONG_OCTET_STRING", strlen("ESP_ZB_ZCL_ATTR_TYPE_LONG_OCTET_STRING"));
        case 0x44:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_LONG_CHAR_STRING", strlen("ESP_ZB_ZCL_ATTR_TYPE_LONG_CHAR_STRING"));
        case 0x48:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_ARRAY", strlen("ESP_ZB_ZCL_ATTR_TYPE_ARRAY"));
        case 0x49:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_16BIT_ARRAY", strlen("ESP_ZB_ZCL_ATTR_TYPE_16BIT_ARRAY"));
        case 0x4a:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_32BIT_ARRAY", strlen("ESP_ZB_ZCL_ATTR_TYPE_32BIT_ARRAY"));
        case 0x4c:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_STRUCTURE", strlen("ESP_ZB_ZCL_ATTR_TYPE_STRUCTURE"));
        case 0x50:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_SET", strlen("ESP_ZB_ZCL_ATTR_TYPE_SET"));
        case 0x51:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_BAG", strlen("ESP_ZB_ZCL_ATTR_TYPE_BAG"));
        case 0xe0:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_TIME_OF_DAY", strlen("ESP_ZB_ZCL_ATTR_TYPE_TIME_OF_DAY"));
        case 0xe1:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_DATE", strlen("ESP_ZB_ZCL_ATTR_TYPE_DATE"));
        case 0xe2:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_UTC_TIME", strlen("ESP_ZB_ZCL_ATTR_TYPE_UTC_TIME"));
        case 0xe8:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_CLUSTER_ID", strlen("ESP_ZB_ZCL_ATTR_TYPE_CLUSTER_ID"));
        case 0xe9:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_ATTRIBUTE_ID", strlen("ESP_ZB_ZCL_ATTR_TYPE_ATTRIBUTE_ID"));
        case 0xea:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_BACNET_OID", strlen("ESP_ZB_ZCL_ATTR_TYPE_BACNET_OID"));
        case 0xf0:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_IEEE_ADDR", strlen("ESP_ZB_ZCL_ATTR_TYPE_IEEE_ADDR"));
        case 0xf1:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_128_BIT_KEY", strlen("ESP_ZB_ZCL_ATTR_TYPE_128_BIT_KEY"));
        case 0xff:
            return mp_obj_new_str("ESP_ZB_ZCL_ATTR_TYPE_INVALID", strlen("ESP_ZB_ZCL_ATTR_TYPE_INVALID"));
        default:
            return mp_obj_new_str("UNKNOWN", 7);
    }
}
static MP_DEFINE_CONST_FUN_OBJ_1(mod_zigbee_attrtype_get_type_obj, mod_zigbee_attrtype_get_type);

// size method implementation  
mp_obj_t mod_zigbee_attrtype_size(mp_obj_t value_in) {
    mp_int_t value = mp_obj_get_int(value_in);
    
    // Return size based on enum type
    // AttrType sizes based on ZigBee data type specification
    switch (value) {
        case 0x08: // UINT8
        case 0x09: // UINT16  
        case 0x0A: // UINT24
        case 0x0B: // UINT32
        case 0x0C: // UINT40
        case 0x0D: // UINT48
        case 0x0E: // UINT56
        case 0x0F: // UINT64
        case 0x10: // INT8
        case 0x11: // INT16
        case 0x12: // INT24
        case 0x13: // INT32
        case 0x14: // INT40
        case 0x15: // INT48
        case 0x16: // INT56
        case 0x17: // INT64
        case 0x18: // ENUM8
        case 0x19: // ENUM16
        case 0x1A: // SEMI_PREC
        case 0x1B: // SINGLE_PREC
        case 0x1C: // DOUBLE_PREC
        case 0x20: // BMP8
        case 0x21: // BMP16
        case 0x22: // BMP24
        case 0x23: // BMP32
        case 0x24: // BMP40
        case 0x25: // BMP48
        case 0x26: // BMP56
        case 0x27: // BMP64
        case 0x28: // UINT8
        case 0x29: // UINT16
        case 0x2A: // UINT24
        case 0x2B: // UINT32
        case 0x2C: // UINT40
        case 0x2D: // UINT48
        case 0x2E: // UINT56
        case 0x2F: // UINT64
        case 0x30: // INT8
        case 0x31: // INT16
        case 0x38: // SEMI_PREC
        case 0x39: // SINGLE_PREC
        case 0x3A: // DOUBLE_PREC
            // Return size based on last hex digit for most types
            return MP_OBJ_NEW_SMALL_INT((value & 0x0F) == 8 ? 1 : 
                                       (value & 0x0F) == 9 ? 2 : 
                                       (value & 0x0F) == 0xA ? 3 : 
                                       (value & 0x0F) == 0xB ? 4 : 
                                       (value & 0x0F) == 0xC ? 5 : 
                                       (value & 0x0F) == 0xD ? 6 : 
                                       (value & 0x0F) == 0xE ? 7 : 
                                       (value & 0x0F) == 0xF ? 8 : 1);
        case 0x41: // OCTET_STRING
        case 0x42: // CHAR_STRING
        case 0x43: // LONG_OCTET_STRING
        case 0x44: // LONG_CHAR_STRING
            return MP_OBJ_NEW_SMALL_INT(-1); // Variable length
        case 0xE0: // TIME_OF_DAY
        case 0xE1: // DATE
        case 0xE2: // UTC_TIME
            return MP_OBJ_NEW_SMALL_INT(4);
        case 0xE8: // CLUSTER_ID
        case 0xE9: // ATTR_ID
        case 0xEA: // BACNET_OID
            return MP_OBJ_NEW_SMALL_INT(2);
        case 0xF0: // EUI64
        case 0xF1: // KEY128
            return MP_OBJ_NEW_SMALL_INT(value == 0xF0 ? 8 : 16);
        case 0xFF: // UNKNOWN
            return MP_OBJ_NEW_SMALL_INT(0);
        default:
            mp_raise_ValueError(MP_ERROR_TEXT("Unknown or invalid attribute type"));
    }
}
static MP_DEFINE_CONST_FUN_OBJ_1(mod_zigbee_attrtype_size_obj, mod_zigbee_attrtype_size);

// Module dictionary - functions and constants directly accessible
static const mp_rom_map_elem_t mp_module_ZCL_ATTR_TYPE_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ZCL_ATTR_TYPE) },
    
    // Module-level functions (not class methods!)
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mod_zigbee_attrtype_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_size), MP_ROM_PTR(&mod_zigbee_attrtype_size_obj) },
    
    // Constants directly in module
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_NULL), MP_ROM_INT(0x00) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_8BIT), MP_ROM_INT(0x08) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_16BIT), MP_ROM_INT(0x09) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_24BIT), MP_ROM_INT(0x0a) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_32BIT), MP_ROM_INT(0x0b) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_40BIT), MP_ROM_INT(0x0c) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_48BIT), MP_ROM_INT(0x0d) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_56BIT), MP_ROM_INT(0x0e) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_64BIT), MP_ROM_INT(0x0f) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_BOOL), MP_ROM_INT(0x10) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_8BITMAP), MP_ROM_INT(0x18) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_16BITMAP), MP_ROM_INT(0x19) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_24BITMAP), MP_ROM_INT(0x1a) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_32BITMAP), MP_ROM_INT(0x1b) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_40BITMAP), MP_ROM_INT(0x1c) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_48BITMAP), MP_ROM_INT(0x1d) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_56BITMAP), MP_ROM_INT(0x1e) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_64BITMAP), MP_ROM_INT(0x1f) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_U8), MP_ROM_INT(0x20) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_U16), MP_ROM_INT(0x21) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_U24), MP_ROM_INT(0x22) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_U32), MP_ROM_INT(0x23) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_U40), MP_ROM_INT(0x24) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_U48), MP_ROM_INT(0x25) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_U56), MP_ROM_INT(0x26) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_U64), MP_ROM_INT(0x27) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_S8), MP_ROM_INT(0x28) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_S16), MP_ROM_INT(0x29) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_S24), MP_ROM_INT(0x2a) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_S32), MP_ROM_INT(0x2b) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_S40), MP_ROM_INT(0x2c) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_S48), MP_ROM_INT(0x2d) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_S56), MP_ROM_INT(0x2e) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_S64), MP_ROM_INT(0x2f) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_8BIT_ENUM), MP_ROM_INT(0x30) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_16BIT_ENUM), MP_ROM_INT(0x31) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_SEMI), MP_ROM_INT(0x38) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_SINGLE), MP_ROM_INT(0x39) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_DOUBLE), MP_ROM_INT(0x3a) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_OCTET_STRING), MP_ROM_INT(0x41) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_CHAR_STRING), MP_ROM_INT(0x42) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_LONG_OCTET_STRING), MP_ROM_INT(0x43) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_LONG_CHAR_STRING), MP_ROM_INT(0x44) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_ARRAY), MP_ROM_INT(0x48) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_16BIT_ARRAY), MP_ROM_INT(0x49) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_32BIT_ARRAY), MP_ROM_INT(0x4a) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_STRUCTURE), MP_ROM_INT(0x4c) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_SET), MP_ROM_INT(0x50) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_BAG), MP_ROM_INT(0x51) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_TIME_OF_DAY), MP_ROM_INT(0xe0) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_DATE), MP_ROM_INT(0xe1) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_UTC_TIME), MP_ROM_INT(0xe2) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_CLUSTER_ID), MP_ROM_INT(0xe8) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_ATTRIBUTE_ID), MP_ROM_INT(0xe9) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_BACNET_OID), MP_ROM_INT(0xea) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_IEEE_ADDR), MP_ROM_INT(0xf0) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_128_BIT_KEY), MP_ROM_INT(0xf1) },
    { MP_ROM_QSTR(MP_QSTR_ESP_ZB_ZCL_ATTR_TYPE_INVALID), MP_ROM_INT(0xff) },
};
static MP_DEFINE_CONST_DICT(mp_module_ZCL_ATTR_TYPE_globals, mp_module_ZCL_ATTR_TYPE_globals_table);

// Module definition
const mp_obj_module_t mp_module_ZCL_ATTR_TYPE = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&mp_module_ZCL_ATTR_TYPE_globals,
};

// Auto-register the module with MicroPython
MP_REGISTER_MODULE(MP_QSTR_ZCL_ATTR_TYPE, mp_module_ZCL_ATTR_TYPE);
